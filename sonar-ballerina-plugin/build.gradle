/*
 * Copyright (c) 2024, WSO2 LLC. (http://www.wso2.org) All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import java.util.jar.JarInputStream

plugins {
    id "com.github.johnrengelman.shadow" version "${shadowPluginVersion}"
    id "io.spring.dependency-management" version "${springDependencyManagementVersion}"
    id 'java'
    id 'java-library'
    id 'application'
    id 'checkstyle'
    id "com.github.spotbugs" version "${spotbugsVersion}"
    id "de.undercouch.download" version "${downloadPluginVersion}"
}

group = 'io.ballerina.sonar'
version = "${sonarPluginVersion}"

repositories {
    mavenLocal()
    mavenCentral()
    gradlePluginPortal()

    maven {
        url = 'https://repox.jfrog.io/repox/plugins.gradle.org/'
    }

    maven {
        url = uri("https://plugins.gradle.org/m2/")
    }
}

dependencies {
    implementation group:'javax.annotation', name:'javax.annotation-api', version: "${javaAnnotationAPIVersion}"

    compileOnly group: 'org.sonarsource.api.plugin', name: 'sonar-plugin-api', version: "${sonarPluginAPIVersion}"
    implementation group: 'org.sonarsource.analyzer-commons', name: 'sonar-analyzer-commons', version: "${sonarAnalyzerCommonsVersion}"
    implementation group: 'org.sonarsource.analyzer-commons', name: 'sonar-xml-parsing', version: "${sonarAnalyzerCommonsVersion}"
    implementation group: 'org.sonarsource.analyzer-commons', name: 'sonar-regex-parsing', version: "${sonarAnalyzerCommonsVersion}"
    implementation group: 'org.sonarsource.analyzer-commons', name: 'sonar-performance-measure', version: "${sonarAnalyzerCommonsVersion}"
    implementation group: 'org.sonarsource.analyzer-commons', name: 'sonar-analyzer-recognizers', version: "${sonarAnalyzerCommonsVersion}"

    implementation group: 'org.sonarsource.scanner.api', name: 'sonar-scanner-api', version: "${sonarScannerAPIVersion}"

    // For Removing slf4j errors
    implementation group: 'org.slf4j', name: 'slf4j-api', version: "${slf4jVersion}"
    implementation group: 'ch.qos.logback', name: 'logback-classic', version: "${logbackVersion}"

    implementation group: 'com.fasterxml.staxmate', name: 'staxmate', version: "${fasterXmlVersion}"
    implementation "com.google.code.gson:gson:${gsonVersion}"

    checkstyle group: 'com.puppycrawl.tools', name: 'checkstyle', version: "${checkstyleVersion}"

    implementation group: 'org.apache.commons', name: 'commons-lang3', version: "${apacheCommonsVersion}"

    testImplementation group: 'org.junit.jupiter', name: 'junit-jupiter-api', version: "${junitVersion}"
    testImplementation group: 'org.junit.jupiter', name: 'junit-jupiter-params', version: "${junitVersion}"
    testImplementation group: 'org.junit.jupiter', name: 'junit-jupiter-engine', version: "${junitVersion}"
    testImplementation group: 'org.assertj', name: 'assertj-core', version: "${assertJCoreVersion}"
    testImplementation group: 'org.mockito', name: 'mockito-core', version: "${mockitoCoreVersion}"
    testImplementation group: 'io.mockk', name: 'mockk', version: "${mockkVersion}"
    testImplementation group: 'io.github.classgraph', name: 'classgraph', version: "${classGraphVersion}"
    testImplementation group: 'org.sonarsource.analyzer-commons', name: 'sonar-analyzer-test-commons', version: "${sonarAnalyzerCommonsVersion}"
    testImplementation group: 'org.sonarsource.orchestrator', name: 'sonar-orchestrator', version: "${sonarOrchestratorVersion}"
    testImplementation group: 'org.sonarsource.sonarlint.core', name: 'sonarlint-core', version: "${sonarLintCoreVersion}"
    testImplementation group: 'org.sonarsource.sonarqube', name: 'sonar-ws', version: "${sonarQubeVersion}"
    testImplementation group: 'org.sonarsource.sonarqube', name: 'sonar-plugin-api-impl', version: "${sonarQubeVersion}"
}

// Setting up checkstyle
// Downloading checkstyle configurations
task downloadCheckstyleRuleFiles(type: Download) {
    src([
            'https://raw.githubusercontent.com/wso2/code-quality-tools/v1.4/checkstyle/jdk-17/checkstyle.xml',
            'https://raw.githubusercontent.com/wso2/code-quality-tools/v1.4/checkstyle/jdk-17/suppressions.xml'
    ])
    overwrite false
    onlyIfNewer true
    dest buildDir
}

// Location for placing checkstyle configurations
artifacts.add('default', file("${project.buildDir}/checkstyle.xml")) {
    builtBy(downloadCheckstyleRuleFiles)
}

// Location for placing the suppression files configurations
artifacts.add('default', file("${project.buildDir}/suppressions.xml")) {
    builtBy(downloadCheckstyleRuleFiles)
}

// Files to be excluded from checkstyle
def excludePattern = '**/module-info.java'
tasks.withType(Checkstyle) {
    exclude excludePattern
}

// Checkstyle outputs locations
checkstyle {
    toolVersion "10.12.1"
    // As in the current implementation the project is as a sub module
    configFile rootProject.file("${project.buildDir}/checkstyle.xml")
    configProperties = ["suppressionFile": file("${project.buildDir}/build/suppressions.xml")]
}

// Enable checkstyles for test files
checkstyleTest {
    enabled = true
}

// Run checkstyle only after downloading the custom checkstyle configurations
checkstyleMain.dependsOn(downloadCheckstyleRuleFiles)
checkstyleTest.dependsOn(downloadCheckstyleRuleFiles)

// Setting up spotbugs
spotbugsMain {
    effort "max"
    reportLevel "low"

    // Spotbugs report destination
    reportsDir = file("$project.buildDir/reports/spotbugs")

    // Spotbugs report types to generate
    reports {
        html.enabled true
        text.enabled = true
    }

    // spotbugs exclusions file destination
    def excludeFile = file("${projectDir}/spotbugs-exclude.xml")
    if (excludeFile.exists()) {
        excludeFilter = excludeFile
    }
}

// Have spotbugs test enabled
spotbugsTest {
    effort = "max"
    reportLevel = "low"

    // Spotbugs report destination
    reportsDir = file("$project.buildDir/reports/spotbugs")

    // Spotbugs report types to generate
    reports {
        html.enabled true
        text.enabled = true
    }

    // spotbugs exclusions file destination
    def excludeFile = file("${projectDir}/spotbugs-exclude.xml")
    if (excludeFile.exists()) {
        excludeFilter = excludeFile
    }
}

task validateSpotbugs() {
    doLast {
        if (spotbugsMain.reports.size() > 0 &&
                spotbugsMain.reports[0].destination.exists() &&
                spotbugsMain.reports[0].destination.text.readLines().size() > 0) {
            spotbugsMain.reports[0].destination?.eachLine {
                println 'Failure: ' + it
            }
        } else {
            throw new GradleException("Spotbugs rule violations were found.");
        }
    }
}

spotbugsMain.finalizedBy validateSpotbugs


// Sonar Plugin API Testing configurations
// Required to run tests relevant to the plugin
tasks.test {
    useJUnitPlatform()
}

// include compileOnly dependencies during test to prevent certificate issues
configurations {
    testImplementation {
        extendsFrom compileOnly
    }
}

// class for testing features
application {
    mainClass = 'io.ballerina.sonar.Main'
}

// JAR creation configurations
// Configurations for the output jar file when the gradle build is performed
// Configure global properties
ext {
    set("buildNumber", System.getProperty("buildNumber"))
}

tasks.jar {
    manifest {
        def displayVersion = (project.property("buildNumber") == null ? project.version : project.version.substring(0, project.version.lastIndexOf('.')) + " (build ${project.property("buildNumber")})")
        def buildDate = new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
        attributes(
                'Build-Time': buildDate,
                'Implementation-Build': 'git rev-parse HEAD'.execute().text.trim(),
                'Plugin-BuildDate': buildDate,
                // Note that use of ChildFirstClassLoader is deprecated since SonarQube 7.9
                'Plugin-ChildFirstClassLoader': 'false',
                'Plugin-Class': 'io.ballerina.sonar.BallerinaPlugin',
                'Plugin-Description': 'Code Analyzer for Ballerina',
                'Plugin-Developers': 'WSO2 Team',
                'Plugin-Display-Version': displayVersion,
                'Plugin-Key': 'ballerina',
                'Plugin-License': 'GNU LGPL 3',
                'Plugin-Name': 'Ballerina Code Quality and Security',
                'Plugin-Organization': 'WSO2',
                'Plugin-OrganizationUrl': 'https://wso2.com/',
                'Plugin-SourcesUrl': 'https://ballerina.io/',
                'Plugin-Version': project.version,
                'Plugin-RequiredForLanguages': 'ballerina',
                'Sonar-Version': '6.7',
                'Version': "${project.version}",
                'Jre-Min-Version': '17'
        )
    }
}

// Configuration required to create the shadow jar file
def shadowJar = tasks.shadowJar

task sourcesJar(type: Jar, dependsOn: classes) {
    archiveClassifier.set('sources')
    from sourceSets.main.allSource
}

tasks.shadowJar {
    minimize {}

    exclude '**/*.js'
    exclude '**/*.properties'
    exclude '**/*.proto'
    exclude '**/*.txt'

    exclude 'sonar-scanner-api-batch.jar'
    exclude 'javax/**'
    exclude 'license/**'
    exclude 'META-INF/maven/**'
    exclude 'META-INF/proguard/**'
    exclude 'META-INF/versions/**'
    exclude 'META-INF/services/com.ctc.wstx.shaded.msv.relaxng_datatype.DatatypeLibraryFactory'
    exclude 'META-INF/services/javax.servlet.ServletContainerInitializer'
    exclude 'META-INF/services/javax.xml.datatype.DatatypeFactory'
    exclude 'META-INF/services/javax.xml.parsers.DocumentBuilderFactory'
    exclude 'META-INF/services/javax.xml.parsers.SAXParserFactory'
    exclude 'META-INF/services/javax.xml.stream.XMLEventFactory'
    exclude 'META-INF/services/javax.xml.stream.XMLInputFactory'
    exclude 'META-INF/services/javax.xml.stream.XMLOutputFactory'
    exclude 'META-INF/services/javax.xml.validation.SchemaFactory'
    exclude 'META-INF/services/org.codehaus.stax2.validation.XMLValidationSchemaFactory'
    exclude 'META-INF/services/org.codehaus.stax2.validation.XMLValidationSchemaFactory.dtd'
    exclude 'META-INF/services/org.codehaus.stax2.validation.XMLValidationSchemaFactory.relaxng'
    exclude 'META-INF/services/org.codehaus.stax2.validation.XMLValidationSchemaFactory.w3c'
    exclude 'META-INF/services/org.w3c.dom.DOMImplementationSourceList'
    exclude 'META-INF/services/org.xml.sax.driver'
    exclude 'META-INF/LICENSE'
    exclude 'META-INF/NOTICE'

    doLast {
        enforceJarSizeAndCheckContent(shadowJar.archiveFile.get().asFile, 10L, 500_000_000L)
    }
}

artifacts {
    archives shadowJar
}

static void enforceJarSizeAndCheckContent(File file, long minSize, long maxSize) {
    long size = file.length()
    if (size < minSize) {
        throw new GradleException("${file.path} size ($size) too small. Min is $minSize")
    } else if (size > maxSize) {
        throw new GradleException("${file.path} size ($size) too large. Max is $maxSize")
    }
    checkJarEntriesPathUniqueness file
}

static void checkJarEntriesPathUniqueness(File file) {
    def allNames = new HashSet()
    def duplicatedNames = new HashSet()
    file.withInputStream { input ->
        new JarInputStream(input).withCloseable { jarInput ->
            for (def jarEntry = jarInput.nextJarEntry; jarEntry != null; jarEntry = jarInput.nextJarEntry) {
                if (!allNames.add(jarEntry.name)) {
                    duplicatedNames.add jarEntry.name
                }
            }
        }
    }
    if (!duplicatedNames.empty) {
        throw new GradleException("Duplicated entries in the jar: '${file.path}': ${duplicatedNames.join(', ')}")
    }
}